import React, { useMemo, useState, useEffect, useCallback } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger, DialogFooter, DialogDescription } from "@/components/ui/dialog";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Checkbox } from "@/components/ui/checkbox";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Upload, Plus, Search, RefreshCw, Settings, Table, Pencil, Trash2, ChevronsUpDown, FileUp, AlertTriangle, ArrowUpDown, Sparkles } from "lucide-react";
import { useDropzone } from 'react-dropzone';
import { ResponsiveContainer, ScatterChart, XAxis, YAxis, CartesianGrid, Scatter, Tooltip, Legend, ZAxis } from "recharts";

/**
 * MinRisk — Version 1.6.2 (Deployment Fix)
 * - Reverted CSV parser to load from CDN to resolve compilation issues.
 * - This version is stable for both preview and local deployment.
 */

// This component requires the papaparse library, loaded from a CDN.
declare const Papa: any;

// ===== TYPES =====
export type Control = { id: string; description: string; target: "Likelihood" | "Impact"; design: number; implementation: number; monitoring: number; effectiveness_evaluation: number; };
export type RiskRow = { risk_code: string; risk_title: string; risk_description: string; division: string; department: string; category: string; owner: string; likelihood_inherent: number; impact_inherent: number; controls: Control[]; status: "Open" | "In Progress" | "Closed"; };
export type AppConfig = {
    matrixSize: 5 | 6;
    likelihoodLabels: string[];
    impactLabels: string[];
    divisions: string[];
    departments: string[];
    categories: string[];
};
type ProcessedRisk = RiskRow & { likelihood_residual: number, impact_residual: number, inherent_score: number, residual_score: number };
type ParsedRisk = Omit<RiskRow, 'risk_code' | 'controls'> & { controls: []; errors?: string[] };
type ParsedControl = Omit<Control, 'id'> & { risk_code: string; risk_title?: string; errors?: string[] };
type DiscoveredConfig = { divisions: string[]; departments: string[]; categories: string[] };
type SortConfig = { key: keyof ProcessedRisk; direction: 'asc' | 'desc'; };
type AISuggestedRisk = { risk_title: string; risk_description: string; };

// ===== CONSTANTS =====
const DEFAULT_APP_CONFIG: AppConfig = {
    matrixSize: 5,
    likelihoodLabels: ["Rare", "Unlikely", "Possible", "Likely", "Almost certain"],
    impactLabels: ["Minimal", "Low", "Moderate", "High", "Severe"],
    divisions: ["Clearing", "Operations", "Finance"],
    departments: ["Risk Management", "IT Ops", "Quant/Risk", "Treasury", "Trading"],
    categories: ["Strategic", "Credit", "Market", "Liquidity", "Operational", "Legal/Compliance", "Technology", "ESG", "Reputational"],
};
const CONTROL_DESIGN_OPTIONS = [{ value: 3, label: "Reduces risks entirely" }, { value: 2, label: "Reduces most aspects of risk" }, { value: 1, label: "Reduces some areas of risk" }, { value: 0, label: "Badly designed or no protection" }];
const CONTROL_IMPLEMENTATION_OPTIONS = [{ value: 3, label: "Always applied as intended" }, { value: 2, label: "Generally operational" }, { value: 1, label: "Sometimes applied correctly" }, { value: 0, "label": "Not applied or applied incorrectly" }];
const CONTROL_MONITORING_OPTIONS = [{ value: 3, label: "Always monitored" }, { value: 2, label: "Usually monitored" }, { value: 1, label: "Monitored on an ad-hoc basis" }, { value: 0, label: "Not monitored at all" }];
const CONTROL_EFFECTIVENESS_OPTIONS = [{ value: 3, label: "Regularly evaluated" }, { value: 2, label: "Occasionally evaluated" }, { value: 1, label: "Infrequently evaluated" }, { value: 0, label: "Never evaluated" }];

const SEED: RiskRow[] = [{ risk_code: "CRD-001", risk_title: "Counterparty default", risk_description: "Clearing member fails to meet obligations; default waterfall.", division: "Clearing", department: "Risk Management", category: "Credit", owner: "Head, Risk", likelihood_inherent: 4, impact_inherent: 5, status: "In Progress", controls: [{ id: "c1", description: "Daily Margin Calls", target: "Impact", design: 3, implementation: 3, monitoring: 3, effectiveness_evaluation: 3 }, { id: "c2", description: "Member Default Fund", target: "Impact", design: 2, implementation: 3, monitoring: 2, effectiveness_evaluation: 2 }] }, { risk_code: "OPR-003", risk_title: "Settlement system outage", risk_description: "Platform unavailable during settlement window.", division: "Operations", department: "IT Ops", category: "Operational", owner: "CTO", likelihood_inherent: 3, impact_inherent: 5, status: "Open", controls: [{ id: "c3", description: "System Redundancy/Failover", target: "Likelihood", design: 3, implementation: 2, monitoring: 3, effectiveness_evaluation: 2 }] }];

// ===== LOGIC & HELPERS =====
const bucket = (l: number, i: number, size: 5 | 6) => {
    const s = l * i;
    if (size === 5) {
        return s >= 20 ? "Severe" : s >= 12 ? "High" : s >= 6 ? "Moderate" : s >= 3 ? "Low" : "Minimal";
    }
    // Scale thresholds for 6x6 matrix
    return s >= 30 ? "Catastrophic" : s >= 20 ? "Severe" : s >= 12 ? "High" : s >= 6 ? "Moderate" : "Low";
};
const scoreColor = (t: string) => {
    switch (t) {
        case "Catastrophic": return "#991b1b";
        case "Severe": return "#dc2626";
        case "High": return "#f97316";
        case "Moderate": return "#facc15";
        case "Low": return "#84cc16";
        default: return "#22c55e"; // Minimal
    }
};
const scoreColorClass = (t: string) => {
    switch (t) {
        case "Catastrophic": return "bg-red-800";
        case "Severe": return "bg-red-600";
        case "High": return "bg-orange-500";
        case "Moderate": return "bg-yellow-400";
        case "Low": return "bg-lime-400";
        default: return "bg-emerald-400"; // Minimal
    }
};
const scoreColorText = (t: string) => (t === "Catastrophic" || t === "Severe" || t === "High") ? "text-white" : "text-black";
const cap3 = (s: string) => (s || "").replace(/[^A-Za-z]/g, "").slice(0, 3).toUpperCase() || "NEW";
const nextRiskCode = (rows: RiskRow[], div: string, cat: string) => { const pre = `${cap3(div)}-${cap3(cat)}`; const nums = rows.filter(r => r && r.risk_code && r.risk_code.startsWith(pre)).map(r => Number((r.risk_code.split("-")[2] || "0").replace(/[^0-9]/g, ""))).filter(Number.isFinite).sort((a, b) => a - b); const n = (nums.at(-1) || 0) + 1; return `${pre}-${String(n).padStart(3, '0')}` };
const calculateControlEffectiveness = (control: Control): number => { if (control.design === 0 || control.implementation === 0) return 0; const totalScore = control.design + control.implementation + control.monitoring + control.effectiveness_evaluation; return totalScore / 12; };
const calculateResidualRisk = (risk: RiskRow) => { const likelihoodControls = risk.controls.filter(c => c.target === 'Likelihood'); const impactControls = risk.controls.filter(c => c.target === 'Impact'); const maxLikelihoodReduction = likelihoodControls.length > 0 ? Math.max(...likelihoodControls.map(calculateControlEffectiveness)) : 0; const maxImpactReduction = impactControls.length > 0 ? Math.max(...impactControls.map(calculateControlEffectiveness)) : 0; const residualLikelihood = risk.likelihood_inherent - (risk.likelihood_inherent - 1) * maxLikelihoodReduction; const residualImpact = risk.impact_inherent - (risk.impact_inherent - 1) * maxImpactReduction; return { likelihood: Math.max(1, residualLikelihood), impact: Math.max(1, residualImpact) }; };

function exportToCsv(filename: string, rows: any[]) {
    const doExport = () => {
        if (!rows || rows.length === 0) {
            alert("No data to export.");
            return;
        }
        const csv = Papa.unparse(rows);
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
    };

    if (typeof Papa === 'undefined') {
        alert("CSV export library is loading. Please try again in a moment.");
        const script = document.createElement('script');
        script.src = "https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js";
        script.onload = doExport;
        document.head.appendChild(script);
    } else {
        doExport();
    }
}

// ===== GEMINI API HELPER =====
const callGeminiAPI = async (prompt: string, schema?: object) => {
    const apiKey = process.env.NEXT_PUBLIC_GEMINI_API_KEY || process.env.GEMINI_API_KEY; // Replaced empty string with environment variable
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

    const payload: any = {
        contents: [{ parts: [{ text: prompt }] }],
    };

    if (schema) {
        payload.generationConfig = {
            responseMimeType: "application/json",
            responseSchema: schema,
        };
    }
    
    let attempts = 0;
    while (attempts < 5) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                throw new Error(`API call failed with status: ${response.status}`);
            }

            const result = await response.json();
            const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
            
            if (!text) {
                 throw new Error("No text returned from API.");
            }
            
            return schema ? JSON.parse(text) : text;
            
        } catch (error) {
            attempts++;
            console.error(`Attempt ${attempts} failed:`, error);
            if (attempts >= 5) {
                throw error; // Rethrow after final attempt
            }
            await new Promise(resolve => setTimeout(resolve, 2 ** attempts * 100)); // Exponential backoff
        }
    }
};


// ===== MAIN APP COMPONENT =====
export default function MinRiskLatest() {
    const [rows, setRows] = useState<RiskRow[]>(SEED);
    const [query, setQuery] = useState("");
    const [config, setConfig] = useState<AppConfig>(DEFAULT_APP_CONFIG);
    const [filters, setFilters] = useState({ divisions: [] as string[], departments: [] as string[], category: "All", status: "All" });
    const [heatMapView, setHeatMapView] = useState({ inherent: true, residual: true });
    const [sortConfig, setSortConfig] = useState<SortConfig | null>(null);
    const [priorityRisks, setPriorityRisks] = useState(new Set<string>());
    const [activeTab, setActiveTab] = useState("register");

    const filtered = useMemo(() => { const q = query.trim().toLowerCase(); return rows.filter(r => { const m = !q || [r.risk_code, r.risk_title, r.risk_description, r.owner, r.category, r.division, r.department].join(" ").toLowerCase().includes(q); const d = filters.divisions.length === 0 || filters.divisions.includes(r.division); const de = filters.departments.length === 0 || filters.departments.includes(r.department); const c = filters.category === "All" || r.category === filters.category; const s = filters.status === "All" || r.status === filters.status; return m && d && de && c && s; }); }, [rows, query, filters]);
    const processedData = useMemo(() => { return filtered.map(r => { const residual = calculateResidualRisk(r); return { ...r, likelihood_residual: residual.likelihood, impact_residual: residual.impact, inherent_score: r.likelihood_inherent * r.impact_inherent, residual_score: residual.likelihood * residual.impact }; }); }, [filtered]);
    
    const sortedData = useMemo(() => {
        let sortableItems = [...processedData];
        if (sortConfig !== null) {
            sortableItems.sort((a, b) => {
                if (a[sortConfig.key] < b[sortConfig.key]) { return sortConfig.direction === 'asc' ? -1 : 1; }
                if (a[sortConfig.key] > b[sortConfig.key]) { return sortConfig.direction === 'asc' ? 1 : -1; }
                return 0;
            });
        }
        return sortableItems;
    }, [processedData, sortConfig]);
    
    const scatterData = useMemo(() => {
        const priorityData = processedData.filter(r => priorityRisks.has(r.risk_code));
        const inherentPoints = heatMapView.inherent ? priorityData.map(r => ({ x: r.likelihood_inherent, y: r.impact_inherent, name: r.risk_code })) : [];
        const residualPoints = heatMapView.residual ? priorityData.map(r => ({ x: r.likelihood_residual, y: r.impact_residual, name: r.risk_code })) : [];
        return { inherent: inherentPoints, residual: residualPoints };
    }, [processedData, heatMapView, priorityRisks]);

    const addMultipleRisks = (risksToAdd: Omit<RiskRow, 'risk_code'>[]) => {
        setRows(prevRows => {
            let tempRows = [...prevRows];
            const newRisksWithCodes = risksToAdd.map(risk => {
                const newRisk = { ...risk, risk_code: nextRiskCode(tempRows, risk.division, risk.category) };
                tempRows.push(newRisk);
                return newRisk;
            });
            return [...prevRows, ...newRisksWithCodes];
        });
    };

    const add = (payload: Omit<RiskRow, 'risk_code'>) => addMultipleRisks([payload]);
    
    const save = (code: string, payload: Omit<RiskRow, 'risk_code'>) => setRows(p => p.map(r => r.risk_code === code ? { ...payload, risk_code: code } : r));
    const remove = (code: string) => {
        setRows(p => p.filter(r => r.risk_code !== code));
        setPriorityRisks(prev => {
            const newSet = new Set(prev);
            newSet.delete(code);
            return newSet;
        });
    };
    
    const handleRiskBulkImport = (newRisks: ParsedRisk[], discoveredConfig: DiscoveredConfig) => {
        setConfig(prevConfig => ({
            ...prevConfig,
            divisions: [...new Set([...prevConfig.divisions, ...discoveredConfig.divisions])],
            departments: [...new Set([...prevConfig.departments, ...discoveredConfig.departments])],
            categories: [...new Set([...prevConfig.categories, ...discoveredConfig.categories])],
        }));
        setRows(prevRows => {
            let tempRowsForCodeGeneration = [...prevRows];
            const processedNewRisks = newRisks.map(riskWithoutCode => {
                const newRiskWithCode = { ...riskWithoutCode, risk_code: nextRiskCode(tempRowsForCodeGeneration, riskWithoutCode.division, riskWithoutCode.category) };
                tempRowsForCodeGeneration.push(newRiskWithCode as RiskRow);
                return newRiskWithCode;
            });
            return [...prevRows, ...processedNewRisks as RiskRow[]];
        });
    };

    const handleControlBulkImport = (newControls: ParsedControl[]) => {
        setRows(currentRows => {
            const rowsMap = new Map(currentRows.map(r => [r.risk_code, { ...r, controls: [...r.controls] }]));
            newControls.forEach(controlData => {
                const risk = rowsMap.get(controlData.risk_code);
                if (risk) {
                    const newControl: Control = {
                        id: crypto.randomUUID(),
                        description: controlData.description,
                        target: controlData.target,
                        design: controlData.design,
                        implementation: controlData.implementation,
                        monitoring: controlData.monitoring,
                        effectiveness_evaluation: controlData.effectiveness_evaluation,
                    };
                    risk.controls.push(newControl);
                }
            });
            return Array.from(rowsMap.values());
        });
    };
    
    const requestSort = (key: keyof ProcessedRisk) => {
        let direction: 'asc' | 'desc' = 'asc';
        if (sortConfig && sortConfig.key === key && sortConfig.direction === 'asc') {
            direction = 'desc';
        }
        setSortConfig({ key, direction });
    };

    return <div className="min-h-screen w-full bg-gray-50 p-6">
        <div className="flex items-center justify-between mb-6">
            <div><h1 className="text-2xl md:text-3xl font-bold">MinRisk</h1><p className="text-sm text-gray-500">Version 1.6.1 (Final)</p></div>
            <div className="flex items-center gap-2">
                <Button variant="outline" onClick={() => { setRows(SEED); setConfig(DEFAULT_APP_CONFIG); }}><RefreshCw className="mr-2 h-4 w-4" />Reset Demo</Button>
                <ConfigDialog config={config} onSave={setConfig} />
            </div>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-5 gap-3 mb-6">
            <div className="col-span-1"><Input placeholder="Search risks..." value={query} onChange={e => setQuery(e.target.value)} /></div>
            <MultiSelectPopover title="Divisions" options={config.divisions} selected={filters.divisions} setSelected={v => setFilters(f => ({ ...f, divisions: v }))} />
            <MultiSelectPopover title="Departments" options={config.departments} selected={filters.departments} setSelected={v => setFilters(f => ({ ...f, departments: v }))} />
            <Select value={filters.category} onValueChange={v => setFilters({ ...filters, category: v })}><SelectTrigger><SelectValue /></SelectTrigger><SelectContent>{["All", ...config.categories].map(x => <SelectItem key={x} value={x}>{x}</SelectItem>)}</SelectContent></Select>
            <Select value={filters.status} onValueChange={v => setFilters({ ...filters, status: v })}><SelectTrigger><SelectValue /></SelectTrigger><SelectContent>{["All", "Open", "In Progress", "Closed"].map(x => <SelectItem key={x} value={x}>{x}</SelectItem>)}</SelectContent></Select>
        </div>

        <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
            <TabsList className="mb-4"><TabsTrigger value="register">Risk Register</TabsTrigger><TabsTrigger value="control_register">Control Register</TabsTrigger><TabsTrigger value="heatmap">Heat Map</TabsTrigger><TabsTrigger value="ai_assistant">✨ AI Assistant</TabsTrigger><TabsTrigger value="import_risks">Risk Import</TabsTrigger><TabsTrigger value="import_controls">Control Import</TabsTrigger></TabsList>
            
            <TabsContent value="register"><RiskRegisterTab sortedData={sortedData} rowCount={rows.length} requestSort={requestSort} onAdd={add} onSave={save} onRemove={remove} config={config} rows={rows} priorityRisks={priorityRisks} setPriorityRisks={setPriorityRisks} /></TabsContent>
            <TabsContent value="control_register"><ControlRegisterTab allRisks={rows} /></TabsContent>
            <TabsContent value="heatmap"><HeatmapTab scatterData={scatterData} heatMapView={heatMapView} setHeatMapView={setHeatMapView} priorityRiskCount={priorityRisks.size} config={config}/></TabsContent>
            <TabsContent value="ai_assistant"><AIAssistantTab onAddMultipleRisks={addMultipleRisks} config={config} onSwitchTab={setActiveTab}/></TabsContent>
            <TabsContent value="import_risks"><RiskImportTab onImport={handleRiskBulkImport} currentConfig={config}/></TabsContent>
            <TabsContent value="import_controls"><ControlImportTab onImport={handleControlBulkImport} allRisks={rows} /></TabsContent>
        </Tabs>
    </div>;
}

// ===== CHILD COMPONENTS =====

function RiskRegisterTab({ sortedData, rowCount, requestSort, onAdd, onSave, onRemove, config, rows, priorityRisks, setPriorityRisks }: { sortedData: ProcessedRisk[]; rowCount: number; requestSort: (key: keyof ProcessedRisk) => void; onAdd: (r: Omit<RiskRow, 'risk_code'>) => void; onSave: (code: string, payload: Omit<RiskRow, 'risk_code'>) => void; onRemove: (code: string) => void; config: AppConfig; rows: RiskRow[]; priorityRisks: Set<string>; setPriorityRisks: React.Dispatch<React.SetStateAction<Set<string>>> }) {
    
    const visibleRiskCodes = useMemo(() => sortedData.map(r => r.risk_code), [sortedData]);
    const selectedVisibleCount = useMemo(() => visibleRiskCodes.filter(code => priorityRisks.has(code)).length, [visibleRiskCodes, priorityRisks]);
    const isAllSelected = selectedVisibleCount > 0 && selectedVisibleCount === visibleRiskCodes.length;
    const isSomeSelected = selectedVisibleCount > 0 && selectedVisibleCount < visibleRiskCodes.length;

    const handleSelectAll = () => {
        setPriorityRisks(prev => {
            const newSet = new Set(prev);
            if (isAllSelected) {
                visibleRiskCodes.forEach(code => newSet.delete(code));
            } else {
                visibleRiskCodes.forEach(code => newSet.add(code));
            }
            return newSet;
        });
    };

    const handlePriorityChange = (riskCode: string, checked: boolean | 'indeterminate') => {
        setPriorityRisks(prev => {
            const newSet = new Set(prev);
            if (checked) {
                newSet.add(riskCode);
            } else {
                newSet.delete(riskCode);
            }
            return newSet;
        });
    };

    const handleExport = () => {
        if (priorityRisks.size === 0) {
            alert("Please select at least one priority risk to export.");
            return;
        }
        const dataToExport = sortedData
            .filter(r => priorityRisks.has(r.risk_code))
            .map((r, index) => ({
                "S/N": index + 1,
                "Risk Code": r.risk_code,
                "Title": r.risk_title,
                "Description": r.risk_description,
                "Category": r.category,
                "Owner": r.owner,
                "Inherent Score": r.inherent_score.toFixed(2),
                "Residual Score": r.residual_score.toFixed(2),
                "Residual Bucket": bucket(r.likelihood_residual, r.impact_residual, config.matrixSize),
                "Status": r.status,
            }));
        exportToCsv("priority_risk_register.csv", dataToExport);
    };

    return (<Card className="rounded-2xl shadow-sm"><CardContent className="p-4"><div className="flex items-center justify-between mb-3"><div className="text-sm text-gray-500">Showing {sortedData.length} of {rowCount} risks</div><div className="flex items-center gap-2"><Button variant="outline" size="sm" onClick={handleExport}><Table className="mr-2 h-4 w-4"/>Export CSV</Button><AddRiskDialog rows={rows} onAdd={onAdd} config={config}/></div></div><div className="overflow-auto rounded-xl border bg-white"><table className="min-w-[980px] w-full text-sm"><thead className="bg-gray-100"><tr>
        <th className="px-3 py-2 text-left font-semibold text-gray-700 w-12">S/N</th>
        <th className="px-3 py-2 text-left font-semibold text-gray-700 w-24">
            <div className="flex items-center gap-2">
                <Checkbox id="select-all" checked={isAllSelected ? true : isSomeSelected ? 'indeterminate' : false} onCheckedChange={handleSelectAll} />
                <Label htmlFor="select-all">Priority</Label>
            </div>
        </th>
        <th className="px-3 py-2 text-left font-semibold text-gray-700">Code</th>
        <th className="px-3 py-2 text-left font-semibold text-gray-700">Title</th>
        <th className="px-3 py-2 text-left font-semibold text-gray-700">Category</th>
        <th className="px-3 py-2 text-left font-semibold text-gray-700">Owner</th>
        <th className="px-3 py-2 text-left font-semibold text-gray-700"><Button variant="ghost" size="sm" onClick={() => requestSort('inherent_score')}>LxI (Inh) <ArrowUpDown className="ml-2 h-4 w-4" /></Button></th>
        <th className="px-3 py-2 text-left font-semibold text-gray-700"><Button variant="ghost" size="sm" onClick={() => requestSort('residual_score')}>LxI (Res) <ArrowUpDown className="ml-2 h-4 w-4" /></Button></th>
        <th className="px-3 py-2 text-left font-semibold text-gray-700">Bucket (Res)</th>
        <th className="px-3 py-2 text-left font-semibold text-gray-700">Status</th>
        <th></th>
    </tr></thead><tbody>{sortedData.map((r,index)=>{const tag=bucket(r.likelihood_residual,r.impact_residual, config.matrixSize); const textColor = scoreColorText(tag); const bgColorClass = scoreColorClass(tag); return(<tr key={r.risk_code} className="border-t"><td className="px-3 py-2 text-center">{index+1}</td>
    <td className="px-3 py-2 text-center"><Checkbox checked={priorityRisks.has(r.risk_code)} onCheckedChange={checked => handlePriorityChange(r.risk_code, checked)} /></td>
    <td className="px-3 py-2 font-medium">{r.risk_code}</td><td className="px-3 py-2">{r.risk_title}</td><td className="px-3 py-2">{r.category}</td><td className="px-3 py-2">{r.owner}</td><td className="px-3 py-2">{r.inherent_score.toFixed(1)}</td><td className="px-3 py-2 font-semibold">{r.residual_score.toFixed(1)}</td><td className="px-3 py-2"><span className={`px-2 py-1 rounded-full text-xs ${bgColorClass} ${textColor}`}>{tag}</span></td><td className="px-3 py-2">{r.status}</td><td className="px-3 py-2"><div className="flex items-center gap-1"><EditRiskDialog initial={r} config={config} onSave={(payload)=>onSave(r.risk_code,payload)}><Button size="sm" variant="ghost"><Pencil className="h-4 w-4"/></Button></EditRiskDialog><DeleteConfirmationDialog onConfirm={()=>onRemove(r.risk_code)} riskCode={r.risk_code}/></div></td></tr>)})}</tbody></table></div></CardContent></Card>);
}

function ControlRegisterTab({ allRisks }: { allRisks: RiskRow[] }) {
    const allControls = useMemo(() => {
        return allRisks.flatMap(risk =>
            risk.controls.map(control => ({
                risk_code: risk.risk_code,
                ...control
            }))
        );
    }, [allRisks]);

    return (
        <Card className="rounded-2xl shadow-sm">
            <CardHeader>
                <CardTitle>Control Register</CardTitle>
            </CardHeader>
            <CardContent className="p-4">
                <div className="overflow-auto rounded-xl border bg-white">
                    <table className="w-full text-sm">
                        <thead className="bg-gray-100">
                            <tr>
                                <th className="px-3 py-2 text-left font-semibold text-gray-700">Risk Code</th>
                                <th className="px-3 py-2 text-left font-semibold text-gray-700">Control Description</th>
                                <th className="px-3 py-2 text-center font-semibold text-gray-700">D</th>
                                <th className="px-3 py-2 text-center font-semibold text-gray-700">I</th>
                                <th className="px-3 py-2 text-center font-semibold text-gray-700">M</th>
                                <th className="px-3 py-2 text-center font-semibold text-gray-700">E</th>
                            </tr>
                        </thead>
                        <tbody>
                            {allControls.map(control => (
                                <tr key={control.id} className="border-t">
                                    <td className="px-3 py-2 font-medium">{control.risk_code}</td>
                                    <td className="px-3 py-2">{control.description}</td>
                                    <td className="px-3 py-2 text-center">{control.design}</td>
                                    <td className="px-3 py-2 text-center">{control.implementation}</td>
                                    <td className="px-3 py-2 text-center">{control.monitoring}</td>
                                    <td className="px-3 py-2 text-center">{control.effectiveness_evaluation}</td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            </CardContent>
        </Card>
    );
}

const CustomHeatmapBackground = (props: any) => {
    const { xAxis, yAxis, size } = props;
    if (!xAxis || !yAxis) return null;
    const { x, y, width, height } = xAxis.layout;

    if (width <= 0 || height <= 0) return null;
    const cellWidth = width / size;
    const cellHeight = height / size;
    const cells = [];
    for (let i = 1; i <= size; i++) { // Impact (Y-axis, from bottom up)
        for (let j = 1; j <= size; j++) { // Likelihood (X-axis, from left right)
            const b = bucket(j, i, size);
            const color = scoreColor(b);
            cells.push(
                <rect
                    key={`${i}-${j}`}
                    x={x + (j - 1) * cellWidth}
                    y={y + (size - i) * cellHeight}
                    width={cellWidth}
                    height={cellHeight}
                    fill={color}
                    fillOpacity={0.4}
                />
            );
        }
    }
    return <g>{cells}</g>;
};

function HeatmapTab({ scatterData, heatMapView, setHeatMapView, priorityRiskCount, config }: { scatterData: { inherent: any[], residual: any[] }; heatMapView: { inherent: boolean, residual: boolean }; setHeatMapView: React.Dispatch<React.SetStateAction<{ inherent: boolean; residual: boolean; }>>; priorityRiskCount: number; config: AppConfig; }) {
    const CustomTooltip = ({ active, payload }: any) => {
        if (active && payload && payload.length) {
            return (
                <div className="bg-white p-2 border rounded shadow-lg text-sm">
                    <p className="font-bold">{`Risk: ${payload[0].payload.name}`}</p>
                    <p>{`Likelihood: ${payload[0].value.toFixed(2)}`}</p>
                    <p>{`Impact: ${payload[1].value.toFixed(2)}`}</p>
                </div>
            );
        }
        return null;
    };
    
    const centeredData = {
        inherent: scatterData.inherent.map(d => ({ ...d, x: d.x - 0.5, y: d.y - 0.5 })),
        residual: scatterData.residual.map(d => ({ ...d, x: d.x - 0.5, y: d.y - 0.5 })),
    };
    
    return (
        <Card className="rounded-2xl shadow-sm">
            <CardContent className="p-4">
                <div className="flex items-center justify-between mb-3">
                    <div className="text-sm text-gray-500">Displaying {priorityRiskCount} priority risk(s)</div>
                    <div className="flex items-center gap-4">
                        <div className="flex items-center gap-2"><Checkbox id="showInherent" checked={heatMapView.inherent} onCheckedChange={c => setHeatMapView(v => ({ ...v, inherent: !!c }))} /><label htmlFor="showInherent" className="text-sm">Show Inherent</label></div>
                        <div className="flex items-center gap-2"><Checkbox id="showResidual" checked={heatMapView.residual} onCheckedChange={c => setHeatMapView(v => ({ ...v, residual: !!c }))} /><label htmlFor="showResidual" className="text-sm">Show Residual</label></div>
                    </div>
                </div>
                <div className="h-[500px] w-full relative">
                    {priorityRiskCount === 0 && (
                        <div className="absolute inset-0 flex items-center justify-center bg-gray-50/50 z-20 rounded-lg">
                            <p className="text-gray-500">No priority risks selected. Please select risks in the Register tab.</p>
                        </div>
                    )}
                    <ResponsiveContainer>
                        <ScatterChart margin={{ top: 20, right: 30, bottom: 80, left: 30 }}>
                            <CustomHeatmapBackground size={config.matrixSize} />
                            <CartesianGrid />
                            <XAxis type="number" dataKey="x" name="Likelihood" domain={[1, config.matrixSize]} ticks={Array.from({ length: config.matrixSize }, (_, i) => i + 1)} allowDecimals={false} interval={0} tickFormatter={t => config.likelihoodLabels[t - 1]} tick={{ transform: "translate(0, 10)" }} />
                            <YAxis type="number" dataKey="y" name="Impact" domain={[1, config.matrixSize]} ticks={Array.from({ length: config.matrixSize }, (_, i) => i + 1)} allowDecimals={false} interval={0} tickFormatter={t => config.impactLabels[t - 1]} />
                            <ZAxis type="number" dataKey="score" range={[150, 400]} />
                            <Tooltip cursor={{ strokeDasharray: '3 3' }} content={<CustomTooltip />} />
                            <Legend verticalAlign="top" height={36} />
                            {heatMapView.inherent && <Scatter name="Inherent" data={centeredData.inherent} fill="#8884d8" />}
                            {heatMapView.residual && <Scatter name="Residual" data={centeredData.residual} fill="#82ca9d" />}
                        </ScatterChart>
                    </ResponsiveContainer>
                </div>
            </CardContent>
        </Card>
    );
}

function AIAssistantTab({ onAddMultipleRisks, config, onSwitchTab }: { onAddMultipleRisks: (risks: Omit<RiskRow, 'risk_code'>[]) => void; config: AppConfig; onSwitchTab: (tab: string) => void; }) {
    const [prompt, setPrompt] = useState("");
    const [loading, setLoading] = useState(false);
    const [suggestions, setSuggestions] = useState<AISuggestedRisk[]>([]);
    const [error, setError] = useState<string | null>(null);

    const suggestRisks = useCallback(async () => {
        if (!prompt.trim()) return;
        setLoading(true);
        setError(null);
        try {
            const systemPrompt = `You are an AI assistant for a risk management application. A user wants to identify potential risks. Based on the following prompt, generate a list of 1-3 distinct, relevant risks with a clear title and description. Respond only with a JSON array of objects, where each object has a 'risk_title' and 'risk_description' field. Do not include any other text or formatting outside the JSON array. The risks should be relevant to a financial services context.
            User prompt: "${prompt}"`;
            
            const schema = { type: "array", items: { type: "object", properties: { risk_title: { type: "string" }, risk_description: { type: "string" } }, required: ["risk_title", "risk_description"] } };
            
            const response: AISuggestedRisk[] = await callGeminiAPI(systemPrompt, schema);
            setSuggestions(response);
            
        } catch (err: any) {
            setError(err.message || "Failed to get suggestions. Please check your API key and network connection.");
        } finally {
            setLoading(false);
        }
    }, [prompt]);

    const handleAdd = (suggestion: AISuggestedRisk) => {
        onAddMultipleRisks([{ ...suggestion, division: "Clearing", department: "Risk Management", category: "Operational", owner: "Undetermined", likelihood_inherent: 3, impact_inherent: 3, controls: [], status: "Open" }]);
        onSwitchTab("register");
    };

    const isApiConfigured = () => {
        const apiKey = process.env.NEXT_PUBLIC_GEMINI_API_KEY || process.env.GEMINI_API_KEY;
        return !!apiKey;
    };

    return (
        <Card className="rounded-2xl shadow-sm">
            <CardHeader>
                <CardTitle className="flex items-center gap-2"><Sparkles className="h-6 w-6 text-yellow-500" />AI Assistant</CardTitle>
                <CardDescription>Generate new risk ideas using Google's Gemini AI.</CardDescription>
            </CardHeader>
            <CardContent className="p-4">
                {!isApiConfigured() && (
                    <div className="p-4 mb-4 rounded-lg bg-yellow-50 border-l-4 border-yellow-400 text-yellow-800 flex items-center">
                        <AlertTriangle className="mr-3 h-5 w-5" />
                        <p>The Gemini API key is not configured. Please set the **`GEMINI_API_KEY`** environment variable to enable this feature.</p>
                    </div>
                )}
                <div className="flex gap-2">
                    <Input placeholder="Describe a potential business scenario to identify risks..." value={prompt} onChange={e => setPrompt(e.target.value)} disabled={loading || !isApiConfigured()} />
                    <Button onClick={suggestRisks} disabled={loading || !isApiConfigured()}>{loading ? "Thinking..." : "Suggest Risks"}</Button>
                </div>
                {error && <p className="text-red-500 text-sm mt-2">{error}</p>}
                {suggestions.length > 0 && (
                    <div className="mt-6">
                        <h3 className="text-lg font-semibold mb-2">Suggested Risks:</h3>
                        <div className="grid gap-4">
                            {suggestions.map((s, i) => (
                                <Card key={i} className="p-4 bg-gray-50 border-none">
                                    <h4 className="font-semibold text-base">{s.risk_title}</h4>
                                    <p className="text-sm text-gray-700">{s.risk_description}</p>
                                    <Button size="sm" className="mt-2" onClick={() => handleAdd(s)}>Add to Register</Button>
                                </Card>
                            ))}
                        </div>
                    </div>
                )}
            </CardContent>
        </Card>
    );
}

function RiskImportTab({ onImport, currentConfig }: { onImport: (risks: ParsedRisk[], discoveredConfig: DiscoveredConfig) => void; currentConfig: AppConfig; }) {
    const [file, setFile] = useState<File | null>(null);
    const [parsingError, setParsingError] = useState<string | null>(null);
    const onDrop = useCallback((acceptedFiles: File[]) => { setFile(acceptedFiles[0]); setParsingError(null); }, []);
    const { getRootProps, getInputProps, isDragActive } = useDropzone({ onDrop, accept: { 'text/csv': ['.csv'] } });

    const handleParse = () => {
        if (!file) { setParsingError("Please select a CSV file to import."); return; }
        setParsingError(null);
        Papa.parse(file, {
            header: true,
            skipEmptyLines: true,
            dynamicTyping: true,
            transformHeader: (header: string) => header.trim().toLowerCase().replace(/[^a-z0-9]/g, '_').replace(/_$/, ''),
            complete: (results: { data: ParsedRisk[]; errors: any[]; meta: any; }) => {
                if (results.errors.length > 0) {
                    setParsingError("CSV parsing errors detected. Please check your file format. First error: " + results.errors[0].message);
                    return;
                }
                const discoveredConfig = { divisions: new Set<string>(), departments: new Set<string>(), categories: new Set<string>() };
                const validRisks = results.data.filter(d => {
                    const isValid = d.risk_title && d.risk_description && d.division && d.department && d.category && d.owner && d.likelihood_inherent && d.impact_inherent;
                    if (isValid) {
                        discoveredConfig.divisions.add(d.division);
                        discoveredConfig.departments.add(d.department);
                        discoveredConfig.categories.add(d.category);
                    }
                    return isValid;
                });
                if (validRisks.length === 0) {
                    setParsingError("No valid risk rows found. Please check column headers and data format.");
                    return;
                }
                onImport(validRisks, { divisions: Array.from(discoveredConfig.divisions), departments: Array.from(discoveredConfig.departments), categories: Array.from(discoveredConfig.categories) });
                setFile(null);
            }
        });
    };

    return (<Card className="rounded-2xl shadow-sm"><CardHeader><CardTitle>Risk Import</CardTitle><CardDescription>Import risks from a CSV file. Columns must match the required format.</CardDescription></CardHeader><CardContent className="p-4"><div {...getRootProps()} className={`border-2 border-dashed rounded-lg p-6 text-center cursor-pointer ${isDragActive ? "border-blue-500 bg-blue-50" : "border-gray-300 bg-gray-50"}`}><input {...getInputProps()}/><FileUp className="mx-auto h-8 w-8 text-gray-400 mb-2"/><p className="text-sm text-gray-500">{isDragActive ? "Drop the file here..." : "Drag 'n' drop a CSV file here, or click to select one"}</p>{file && <p className="mt-2 text-sm text-green-600">Selected file: {file.name}</p>}</div>{parsingError && <p className="text-red-500 text-sm mt-2">{parsingError}</p>}<Button onClick={handleParse} disabled={!file} className="mt-4"><Upload className="mr-2 h-4 w-4"/>Import Risks</Button><p className="text-sm text-gray-500 mt-4">Required columns: `risk_title`, `risk_description`, `division`, `department`, `category`, `owner`, `likelihood_inherent`, `impact_inherent`.</p></CardContent></Card>);
}

function ControlImportTab({ onImport, allRisks }: { onImport: (controls: ParsedControl[]) => void; allRisks: RiskRow[]; }) {
    const [file, setFile] = useState<File | null>(null);
    const [parsingError, setParsingError] = useState<string | null>(null);
    const onDrop = useCallback((acceptedFiles: File[]) => { setFile(acceptedFiles[0]); setParsingError(null); }, []);
    const { getRootProps, getInputProps, isDragActive } = useDropzone({ onDrop, accept: { 'text/csv': ['.csv'] } });

    const handleParse = () => {
        if (!file) { setParsingError("Please select a CSV file to import."); return; }
        setParsingError(null);
        Papa.parse(file, {
            header: true,
            skipEmptyLines: true,
            dynamicTyping: true,
            transformHeader: (header: string) => header.trim().toLowerCase().replace(/[^a-z0-9]/g, '_').replace(/_$/, ''),
            complete: (results: { data: ParsedControl[]; errors: any[]; meta: any; }) => {
                if (results.errors.length > 0) {
                    setParsingError("CSV parsing errors detected. Please check your file format. First error: " + results.errors[0].message);
                    return;
                }
                const validControls = results.data.filter(d => d.risk_code && d.description);
                if (validControls.length === 0) {
                    setParsingError("No valid control rows found. Please check column headers and data format.");
                    return;
                }
                onImport(validControls);
                setFile(null);
            }
        });
    };

    return (<Card className="rounded-2xl shadow-sm"><CardHeader><CardTitle>Control Import</CardTitle><CardDescription>Import controls from a CSV file. They will be linked to existing risks by `risk_code`.</CardDescription></CardHeader><CardContent className="p-4"><div {...getRootProps()} className={`border-2 border-dashed rounded-lg p-6 text-center cursor-pointer ${isDragActive ? "border-blue-500 bg-blue-50" : "border-gray-300 bg-gray-50"}`}><input {...getInputProps()}/><FileUp className="mx-auto h-8 w-8 text-gray-400 mb-2"/><p className="text-sm text-gray-500">{isDragActive ? "Drop the file here..." : "Drag 'n' drop a CSV file here, or click to select one"}</p>{file && <p className="mt-2 text-sm text-green-600">Selected file: {file.name}</p>}</div>{parsingError && <p className="text-red-500 text-sm mt-2">{parsingError}</p>}<Button onClick={handleParse} disabled={!file} className="mt-4"><Upload className="mr-2 h-4 w-4"/>Import Controls</Button><p className="text-sm text-gray-500 mt-4">Required columns: `risk_code`, `description`, `target`, `design`, `implementation`, `monitoring`, `effectiveness_evaluation`.</p></CardContent></Card>);
}

function AddRiskDialog({ onAdd, config, rows }: { onAdd: (r: Omit<RiskRow, 'risk_code'>) => void; config: AppConfig; rows: RiskRow[]; }) {
    const [open, setOpen] = useState(false);
    const [newRisk, setNewRisk] = useState<Omit<RiskRow, 'risk_code'>>({ risk_title: "", risk_description: "", division: "", department: "", category: "", owner: "", likelihood_inherent: 3, impact_inherent: 3, controls: [], status: "Open" });
    const canSave = newRisk.risk_title && newRisk.risk_description && newRisk.division && newRisk.department && newRisk.category && newRisk.owner;
    
    const handleSave = () => { onAdd(newRisk); setNewRisk({ risk_title: "", risk_description: "", division: "", department: "", category: "", owner: "", likelihood_inherent: 3, impact_inherent: 3, controls: [], status: "Open" }); setOpen(false); };
    
    return (<Dialog open={open} onOpenChange={setOpen}><DialogTrigger asChild><Button><Plus className="mr-2 h-4 w-4"/>Add Risk</Button></DialogTrigger><DialogContent className="sm:max-w-[700px] max-h-[90vh] overflow-y-auto"><DialogHeader><DialogTitle>Add New Risk</DialogTitle></DialogHeader><div className="grid gap-4 py-4"><div className="grid grid-cols-4 items-center gap-4"><Label htmlFor="title" className="text-right">Title</Label><Input id="title" value={newRisk.risk_title} onChange={e => setNewRisk({...newRisk, risk_title: e.target.value})} className="col-span-3"/></div><div className="grid grid-cols-4 items-start gap-4"><Label htmlFor="description" className="text-right">Description</Label><Textarea id="description" value={newRisk.risk_description} onChange={e => setNewRisk({...newRisk, risk_description: e.target.value})} className="col-span-3"/></div><div className="grid grid-cols-4 items-center gap-4"><Label htmlFor="division" className="text-right">Division</Label><Select onValueChange={v => setNewRisk({...newRisk, division: v})} value={newRisk.division}><SelectTrigger className="col-span-3"><SelectValue placeholder="Select a division"/></SelectTrigger><SelectContent>{config.divisions.map(d => <SelectItem key={d} value={d}>{d}</SelectItem>)}</SelectContent></Select></div><div className="grid grid-cols-4 items-center gap-4"><Label htmlFor="department" className="text-right">Department</Label><Select onValueChange={v => setNewRisk({...newRisk, department: v})} value={newRisk.department}><SelectTrigger className="col-span-3"><SelectValue placeholder="Select a department"/></SelectTrigger><SelectContent>{config.departments.map(d => <SelectItem key={d} value={d}>{d}</SelectItem>)}</SelectContent></Select></div><div className="grid grid-cols-4 items-center gap-4"><Label htmlFor="category" className="text-right">Category</Label><Select onValueChange={v => setNewRisk({...newRisk, category: v})} value={newRisk.category}><SelectTrigger className="col-span-3"><SelectValue placeholder="Select a category"/></SelectTrigger><SelectContent>{config.categories.map(c => <SelectItem key={c} value={c}>{c}</SelectItem>)}</SelectContent></Select></div><div className="grid grid-cols-4 items-center gap-4"><Label htmlFor="owner" className="text-right">Owner</Label><Input id="owner" value={newRisk.owner} onChange={e => setNewRisk({...newRisk, owner: e.target.value})} className="col-span-3"/></div><div className="grid grid-cols-4 items-center gap-4"><Label htmlFor="inherent" className="text-right">Inherent Risk (LxI)</Label><div className="col-span-3 flex items-center gap-4"><Select onValueChange={v => setNewRisk({...newRisk, likelihood_inherent: Number(v)})} value={String(newRisk.likelihood_inherent)}><SelectTrigger className="w-[120px]"><SelectValue placeholder="Likelihood"/></SelectTrigger><SelectContent>{Array.from({length: config.matrixSize}, (_,i) => i+1).map(n => <SelectItem key={n} value={String(n)}>{n}</SelectItem>)}</SelectContent></Select>x<Select onValueChange={v => setNewRisk({...newRisk, impact_inherent: Number(v)})} value={String(newRisk.impact_inherent)}><SelectTrigger className="w-[120px]"><SelectValue placeholder="Impact"/></SelectTrigger><SelectContent>{Array.from({length: config.matrixSize}, (_,i) => i+1).map(n => <SelectItem key={n} value={String(n)}>{n}</SelectItem>)}</SelectContent></Select></div></div></div><DialogFooter><Button type="button" onClick={handleSave} disabled={!canSave}>Save Risk</Button></DialogFooter></DialogContent></Dialog>);
}

function EditRiskDialog({ initial, onSave, config, children }: { initial: RiskRow; onSave: (p: Omit<RiskRow, 'risk_code'>) => void; config: AppConfig; children: React.ReactNode; }) {
    const [open, setOpen] = useState(false);
    const [editedRisk, setEditedRisk] = useState(initial);
    const canSave = editedRisk.risk_title && editedRisk.risk_description && editedRisk.division && editedRisk.department && editedRisk.category && editedRisk.owner;
    
    useEffect(() => { setEditedRisk(initial); }, [initial]);
    
    const handleSave = () => { onSave(editedRisk); setOpen(false); };
    
    const addControl = () => { setEditedRisk(r => ({ ...r, controls: [...r.controls, { id: crypto.randomUUID(), description: "", target: "Likelihood", design: 0, implementation: 0, monitoring: 0, effectiveness_evaluation: 0 }] })); };
    const updateControl = (id: string, updates: Partial<Control>) => { setEditedRisk(r => ({ ...r, controls: r.controls.map(c => c.id === id ? { ...c, ...updates } : c) })); };
    const removeControl = (id: string) => { setEditedRisk(r => ({ ...r, controls: r.controls.filter(c => c.id !== id) })); };
    
    return (<Dialog open={open} onOpenChange={setOpen}><DialogTrigger asChild>{children}</DialogTrigger><DialogContent className="sm:max-w-[700px] max-h-[90vh] overflow-y-auto"><DialogHeader><DialogTitle>Edit Risk: {initial.risk_code}</DialogTitle></DialogHeader><div className="grid gap-4 py-4"><div className="grid grid-cols-4 items-center gap-4"><Label htmlFor="title" className="text-right">Title</Label><Input id="title" value={editedRisk.risk_title} onChange={e => setEditedRisk({...editedRisk, risk_title: e.target.value})} className="col-span-3"/></div><div className="grid grid-cols-4 items-start gap-4"><Label htmlFor="description" className="text-right">Description</Label><Textarea id="description" value={editedRisk.risk_description} onChange={e => setEditedRisk({...editedRisk, risk_description: e.target.value})} className="col-span-3"/></div><div className="grid grid-cols-4 items-center gap-4"><Label htmlFor="division" className="text-right">Division</Label><Select onValueChange={v => setEditedRisk({...editedRisk, division: v})} value={editedRisk.division}><SelectTrigger className="col-span-3"><SelectValue placeholder="Select a division"/></SelectTrigger><SelectContent>{config.divisions.map(d => <SelectItem key={d} value={d}>{d}</SelectItem>)}</SelectContent></Select></div><div className="grid grid-cols-4 items-center gap-4"><Label htmlFor="department" className="text-right">Department</Label><Select onValueChange={v => setEditedRisk({...editedRisk, department: v})} value={editedRisk.department}><SelectTrigger className="col-span-3"><SelectValue placeholder="Select a department"/></SelectTrigger><SelectContent>{config.departments.map(d => <SelectItem key={d} value={d}>{d}</SelectItem>)}</SelectContent></Select></div><div className="grid grid-cols-4 items-center gap-4"><Label htmlFor="category" className="text-right">Category</Label><Select onValueChange={v => setEditedRisk({...editedRisk, category: v})} value={editedRisk.category}><SelectTrigger className="col-span-3"><SelectValue placeholder="Select a category"/></SelectTrigger><SelectContent>{config.categories.map(c => <SelectItem key={c} value={c}>{c}</SelectItem>)}</SelectContent></Select></div><div className="grid grid-cols-4 items-center gap-4"><Label htmlFor="owner" className="text-right">Owner</Label><Input id="owner" value={editedRisk.owner} onChange={e => setEditedRisk({...editedRisk, owner: e.target.value})} className="col-span-3"/></div><div className="grid grid-cols-4 items-center gap-4"><Label htmlFor="status" className="text-right">Status</Label><Select onValueChange={v => setEditedRisk({...editedRisk, status: v as any})} value={editedRisk.status}><SelectTrigger className="col-span-3"><SelectValue placeholder="Select status"/></SelectTrigger><SelectContent>{["Open", "In Progress", "Closed"].map(s => <SelectItem key={s} value={s}>{s}</SelectItem>)}</SelectContent></Select></div><div className="grid grid-cols-4 items-center gap-4"><Label htmlFor="inherent" className="text-right">Inherent Risk</Label><div className="col-span-3 flex items-center gap-4"><Select onValueChange={v => setEditedRisk({...editedRisk, likelihood_inherent: Number(v)})} value={String(editedRisk.likelihood_inherent)}><SelectTrigger className="w-[120px]"><SelectValue placeholder="Likelihood"/></SelectTrigger><SelectContent>{Array.from({length: config.matrixSize}, (_,i) => i+1).map(n => <SelectItem key={n} value={String(n)}>{n}</SelectItem>)}</SelectContent></Select>x<Select onValueChange={v => setEditedRisk({...editedRisk, impact_inherent: Number(v)})} value={String(editedRisk.impact_inherent)}><SelectTrigger className="w-[120px]"><SelectValue placeholder="Impact"/></SelectTrigger><SelectContent>{Array.from({length: config.matrixSize}, (_,i) => i+1).map(n => <SelectItem key={n} value={String(n)}>{n}</SelectItem>)}</SelectContent></Select></div></div></div><h3 className="text-lg font-semibold">Controls ({editedRisk.controls.length})</h3><div className="grid gap-4">{editedRisk.controls.map((c, i) => (<Card key={c.id} className="p-4"><div className="flex items-center justify-between mb-2"><Label>Control #{i+1}</Label><Button variant="ghost" size="icon" onClick={() => removeControl(c.id)}><Trash2 className="h-4 w-4"/></Button></div><div className="grid grid-cols-4 items-center gap-4"><Label htmlFor={`c-desc-${c.id}`} className="text-right">Description</Label><Input id={`c-desc-${c.id}`} value={c.description} onChange={e => updateControl(c.id, { description: e.target.value })} className="col-span-3"/></div><div className="grid grid-cols-4 items-center gap-4 mt-2"><Label htmlFor={`c-target-${c.id}`} className="text-right">Target</Label><RadioGroup id={`c-target-${c.id}`} value={c.target} onValueChange={v => updateControl(c.id, { target: v as "Likelihood" | "Impact" })} className="col-span-3 flex"><RadioGroupItem value="Likelihood" id={`l-${c.id}`} /><Label htmlFor={`l-${c.id}`}>Likelihood</Label><RadioGroupItem value="Impact" id={`i-${c.id}`} /><Label htmlFor={`i-${c.id}`}>Impact</Label></RadioGroup></div><div className="grid grid-cols-4 items-center gap-4 mt-2"><Label htmlFor={`c-des-${c.id}`} className="text-right">Design</Label><Select onValueChange={v => updateControl(c.id, { design: Number(v) })} value={String(c.design)}><SelectTrigger className="col-span-3"><SelectValue/></SelectTrigger><SelectContent>{CONTROL_DESIGN_OPTIONS.map(o => <SelectItem key={o.value} value={String(o.value)}>{o.label}</SelectItem>)}</SelectContent></Select></div><div className="grid grid-cols-4 items-center gap-4 mt-2"><Label htmlFor={`c-imp-${c.id}`} className="text-right">Implementation</Label><Select onValueChange={v => updateControl(c.id, { implementation: Number(v) })} value={String(c.implementation)}><SelectTrigger className="col-span-3"><SelectValue/></SelectTrigger><SelectContent>{CONTROL_IMPLEMENTATION_OPTIONS.map(o => <SelectItem key={o.value} value={String(o.value)}>{o.label}</SelectItem>)}</SelectContent></Select></div><div className="grid grid-cols-4 items-center gap-4 mt-2"><Label htmlFor={`c-mon-${c.id}`} className="text-right">Monitoring</Label><Select onValueChange={v => updateControl(c.id, { monitoring: Number(v) })} value={String(c.monitoring)}><SelectTrigger className="col-span-3"><SelectValue/></SelectTrigger><SelectContent>{CONTROL_MONITORING_OPTIONS.map(o => <SelectItem key={o.value} value={String(o.value)}>{o.label}</SelectItem>)}</SelectContent></Select></div><div className="grid grid-cols-4 items-center gap-4 mt-2"><Label htmlFor={`c-eff-${c.id}`} className="text-right">Effectiveness Evaluation</Label><Select onValueChange={v => updateControl(c.id, { effectiveness_evaluation: Number(v) })} value={String(c.effectiveness_evaluation)}><SelectTrigger className="col-span-3"><SelectValue/></SelectTrigger><SelectContent>{CONTROL_EFFECTIVENESS_OPTIONS.map(o => <SelectItem key={o.value} value={String(o.value)}>{o.label}</SelectItem>)}</SelectContent></Select></div></Card>))}</div><Button variant="outline" className="w-full mt-4" onClick={addControl}><Plus className="mr-2 h-4 w-4"/>Add Control</Button><DialogFooter><Button type="button" onClick={handleSave} disabled={!canSave}>Save Changes</Button></DialogFooter></DialogContent></Dialog>);
}

function DeleteConfirmationDialog({ onConfirm, riskCode }: { onConfirm: () => void; riskCode: string; }) {
    const [open, setOpen] = useState(false);
    return (<Dialog open={open} onOpenChange={setOpen}><DialogTrigger asChild><Button size="sm" variant="ghost"><Trash2 className="h-4 w-4 text-red-500"/></Button></DialogTrigger><DialogContent><DialogHeader><DialogTitle>Are you absolutely sure?</DialogTitle><DialogDescription>This action cannot be undone. This will permanently delete the risk with code **{riskCode}** and all associated data from the register.</DialogDescription></DialogHeader><DialogFooter><Button variant="outline" onClick={() => setOpen(false)}>Cancel</Button><Button variant="destructive" onClick={onConfirm}>Delete</Button></DialogFooter></DialogContent></Dialog>);
}

function ConfigDialog({ config, onSave }: { config: AppConfig; onSave: (c: AppConfig) => void; }) {
    const [open, setOpen] = useState(false);
    const [editedConfig, setEditedConfig] = useState(config);

    useEffect(() => { setEditedConfig(config); }, [config]);

    const handleSave = () => { onSave(editedConfig); setOpen(false); };

    return (<Dialog open={open} onOpenChange={setOpen}><DialogTrigger asChild><Button variant="outline"><Settings className="mr-2 h-4 w-4" />Settings</Button></DialogTrigger><DialogContent><DialogHeader><DialogTitle>App Settings</DialogTitle></DialogHeader><div className="grid gap-4 py-4"><div className="grid grid-cols-4 items-center gap-4"><Label htmlFor="matrixSize" className="text-right">Matrix Size</Label><Select onValueChange={v => setEditedConfig(c => ({ ...c, matrixSize: Number(v) as 5 | 6 }))} value={String(editedConfig.matrixSize)}><SelectTrigger className="col-span-3"><SelectValue/></SelectTrigger><SelectContent><SelectItem value="5">5x5 (Default)</SelectItem><SelectItem value="6">6x6</SelectItem></SelectContent></Select></div><div className="grid grid-cols-4 items-start gap-4"><Label htmlFor="divisions" className="text-right">Divisions</Label><Textarea id="divisions" value={editedConfig.divisions.join("\n")} onChange={e => setEditedConfig(c => ({ ...c, divisions: e.target.value.split("\n").map(s => s.trim()).filter(Boolean) }))} className="col-span-3" placeholder="Enter one per line..."/></div><div className="grid grid-cols-4 items-start gap-4"><Label htmlFor="departments" className="text-right">Departments</Label><Textarea id="departments" value={editedConfig.departments.join("\n")} onChange={e => setEditedConfig(c => ({ ...c, departments: e.target.value.split("\n").map(s => s.trim()).filter(Boolean) }))} className="col-span-3" placeholder="Enter one per line..."/></div><div className="grid grid-cols-4 items-start gap-4"><Label htmlFor="categories" className="text-right">Categories</Label><Textarea id="categories" value={editedConfig.categories.join("\n")} onChange={e => setEditedConfig(c => ({ ...c, categories: e.target.value.split("\n").map(s => s.trim()).filter(Boolean) }))} className="col-span-3" placeholder="Enter one per line..."/></div></div><DialogFooter><Button onClick={handleSave}>Save</Button></DialogFooter></DialogContent></Dialog>);
}

function MultiSelectPopover({ title, options, selected, setSelected }: { title: string; options: string[]; selected: string[]; setSelected: (v: string[]) => void; }) {
    return (<Popover><PopoverTrigger asChild><Button variant="outline" className="w-full justify-between"><div className="truncate">{selected.length === 0 ? title : `${title} (${selected.length})`}</div><ChevronsUpDown className="ml-2 h-4 w-4 opacity-50"/></Button></PopoverTrigger><PopoverContent className="w-[300px] p-0"><div className="max-h-60 overflow-y-auto"><div className="p-2"><div className="flex items-center space-x-2"><Checkbox id="select-all" checked={selected.length === options.length} onCheckedChange={(checked) => setSelected(checked ? options : [])}/><Label htmlFor="select-all">Select All</Label></div></div><div className="p-2 border-t">{options.map(o => (<div key={o} className="flex items-center space-x-2 p-1"><Checkbox id={o} checked={selected.includes(o)} onCheckedChange={(checked) => { setSelected(checked ? [...selected, o] : selected.filter(s => s !== o)); }}/><Label htmlFor={o}>{o}</Label></div>))}</div></div></PopoverContent></Popover>);
}
This video provides a straightforward guide on how to get a free Gemini API key using the Google AI Studio interface.
